"use strict";var i=require("node:fs"),S=require("execa");const b="action.yml",F=".ghaignore",f=".gitignore",x=".backup",I=(s,t)=>{if(!i.existsSync(s))return;let e=s+t;for(;i.existsSync(e);)e=e+t;return i.copyFileSync(s,e),e},R=(s,t)=>t.split(".").reduce((e,n)=>e?.[n],s),$=s=>{const t=new Set;for(const e of s.split(/\r?\n/)){const n=e.split("#")[0].trim();typeof n=="string"&&n!==""&&t.add(n)}return Array.from(t)},w=(s,t="")=>[...t.matchAll(/{(.*?)}/g)].map(e=>e[1]).reduce((e,n)=>{const c=R(s,n);return e.replace(`{${n}}`,`${c}`)},t),k=({branch:s,nextRelease:t})=>({branch:s.name,version:t.version,tag:t.gitTag,notes:t.notes??""}),q=(s,t)=>{const e={ghaIgnores:[],gitIgnores:[]};if(!i.existsSync(s))return e;const n=t??i.readFileSync(s,"utf8");e.ghaIgnores=$(n);const c=I(f,x);if(c!==void 0){e.backupFile=c;const a=i.readFileSync(c,"utf8");e.gitIgnores=$(a),i.rmSync(f,{force:!0})}return i.copyFileSync(s,f),e},C=(s="")=>{i.existsSync(s)&&(i.rmSync(f,{force:!0}),i.copyFileSync(s,f),i.rmSync(s,{force:!0}))},u=async(s,t=[])=>await S.execa("git",[s,...t]),E=(s,{force:t=!1}={})=>{const e=[];return t&&e.push("-f"),[...e,"--",s]},N=async(s,t={})=>{const e=E(s,t);return await u("add",e)},A=(s,{allowEmpty:t=!1,keyid:e,sign:n=!1}={})=>{const c=[];if(n){const a="-S",r=typeof e=="string"&&e!==""?`${a}${e}`:a;c.push(r)}return t&&c.push("--allow-empty"),[...c,"-m",`${s}`]},G=async(s,t={})=>{const e=A(s,t);return await u("commit",e)},O=(s,{get:t=!1,list:e=!1,unset:n=!1,scope:c="local",value:a}={})=>{const r=[`--${c}`];return a!=null?r.push(`${s}`,`${a.toString()}`):t?r.push("--get",`${s}`):n?r.push("--unset",`${s}`):e&&r.push("--list"),r},y=async(s,t)=>{const e=O(s,t);return await u("config",e)},U=async(s,t="local")=>{const{stdout:e}=await y(s,{get:!0,scope:t});if(e==="false")return!1;if(e==="true")return!0;const n=Number(e);return Number.isNaN(n)?e:n},_=async(s,t,e="local")=>await y(s,{scope:e,value:t}),j=(s,{tags:t=!1}={})=>{const e=[];let n="";return t===!0&&e.push("--tags"),typeof t=="string"&&(n=t),[...e,s,n]},M=async(s,t={})=>{const e=j(s,t);return await u("ls-remote",e)},T=(s,{delete:t=!1,force:e=!1,remote:n="origin",signed:c=!1}={})=>{const a=[n,s];return t?[n,"-d",s]:(e&&a.push("-f"),c!==!1&&a.push(`--signed=${c}`),a)},P=async(s,t={})=>{const e=T(s,t);return await u("push",e)},B=(s,{quiet:t=!1}={})=>{const e=[];return t&&e.push("-q"),[...e,"--",s]},H=async(s,t={})=>{const e=B(s,t);return await u("reset",e)},K=(s,{cached:t=!1,force:e=!1,ignoreUnmatch:n=!1,quiet:c=!1,recursive:a=!1}={})=>{const r=[];return e&&r.push("-f"),t&&r.push("--cached"),n&&r.push("--ignore-unmatch"),c&&r.push("-q"),a&&r.push("-r"),[...r,"--",s]},L=async(s,t={})=>{const e=K(s,t);return await u("rm",e)},W=(s,{commit:t,delete:e=!1,force:n=!1,list:c=!1,message:a="",sign:r=!1}={})=>{if(e)return["-d",s];if(c)return s===""?["-l"]:["-l",s];const o=[];return n&&o.push("-f"),r&&o.push("-s"),o.push(s),t!==void 0&&o.push(t),[...o,"-m",`${a}`]},X=async(s,t={})=>{const e=W(s,t);return await u("tag",e)},Y=s=>({value:s,enumerable:!0,configurable:!1,writable:!1}),z=(s,t)=>{Object.keys(t).forEach(e=>{const n=Y(t[e]);Object.defineProperty(s,e,n)})};z(u,{add:N,commit:G,config:y,getConfig:U,setConfig:_,lsRemote:M,push:P,reset:H,rm:L,tag:X});const v=async(s,t,{branch:e,message:n,sign:c,tag:a})=>{await u.add(".");for(const r of s)t.includes(r)||await u.rm(r,{force:!0,cached:!0,ignoreUnmatch:!0,recursive:r.endsWith("/"),quiet:!0});for(const r of t)if(!s.includes(r))try{await u.add(r,{force:!0})}catch(o){if(!(o instanceof Error))throw new Error("Unknown error",{cause:o});if(!("message"in o)||typeof o.message!="string"||!o.message.includes(`fatal: pathspec '${r}' did not match any files`))throw o}await u.commit(n,{allowEmpty:!0,sign:c}),await u.push(e),!(typeof a!="string"||a==="")&&(await u.tag(a,{force:!0,message:n,sign:c}),await u.push(a,{force:!0}))},D=(s,t)=>{if(!i.existsSync(s))return;const e=i.readFileSync(s,"utf8").split(/\r?\n/),n=/^(\s*)version\s*:\s*([^\s#]+)(\s*)(#.*)?$/,c=/^(\s*)name\s*:\s*(.+)$/;let a=!1,r=-1;for(let l=0;l<e.length;l++){const g=e[l].match(n);if(g!=null){const[,h,,p,d]=g;e[l]=`${h}version: ${t}${p!==""?p:" "}${d!==""?d:""}`,a=!0;break}e[l].match(c)!=null&&(r=l)}if(!a){const l=`version: ${t}`;r>=0?e.splice(r+1,0,l):e.unshift(l)}const o=e.join(`
`);i.rmSync(s,{force:!0}),i.writeFileSync(s,o,"utf8")},J=async({actionFile:s=b,ignoreFile:t=F,ignoreContent:e,latestMessage:n=`latest: v{nextRelease.version}

{nextRelease.notes}`,releaseMessage:c=`release: v{nextRelease.version}

{nextRelease.notes}`,sign:a=!1}={},r)=>{const{branch:o,tag:l,version:g}=k(r),{ghaIgnores:m,gitIgnores:h,backupFile:p}=q(t,e);D(s,g),await v(m,h,{branch:o,message:w(r,c),sign:a,tag:l}),C(p),await v(h,m,{branch:o,message:w(r,n),sign:a})};exports.publish=J;
