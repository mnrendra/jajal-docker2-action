#!/usr/bin/env node
"use strict";var p=require("node:process"),pe=require("semantic-release"),C=require("execa"),$=require("node:fs"),S=require("node:path"),L=require("node:os"),K=require("nanoid"),fe=require("openpgp"),Ge=require("addressparser"),f=require("@actions/core");const de="/github/workspace",M=e=>typeof e=="object"&&e!==null&&!Array.isArray(e)&&"__esModule"in e&&e.__esModule===!0&&"default"in e?e.default:e,d=async(e,t=[])=>await C.execa("git",[e,...t]),we=(e,{force:t=!1}={})=>{const r=[];return t&&r.push("-f"),[...r,"--",e]},ye=async(e,t={})=>{const r=we(e,t);return await d("add",r)},$e=(e,{allowEmpty:t=!1,keyid:r,sign:n=!1}={})=>{const s=[];if(n){const o="-S",a=typeof r=="string"&&r!==""?`${o}${r}`:o;s.push(a)}return t&&s.push("--allow-empty"),[...s,"-m",`${e}`]},me=async(e,t={})=>{const r=$e(e,t);return await d("commit",r)},he=(e,{get:t=!1,list:r=!1,unset:n=!1,scope:s="local",value:o}={})=>{const a=[`--${s}`];return o!=null?a.push(`${e}`,`${o.toString()}`):t?a.push("--get",`${e}`):n?a.push("--unset",`${e}`):r&&a.push("--list"),a},N=async(e,t)=>{const r=he(e,t);return await d("config",r)},m=async(e,t="local")=>{const{stdout:r}=await N(e,{get:!0,scope:t});if(r==="false")return!1;if(r==="true")return!0;const n=Number(r);return Number.isNaN(n)?r:n},h=async(e,t,r="local")=>await N(e,{scope:r,value:t}),Ie=(e,{tags:t=!1}={})=>{const r=[];let n="";return t===!0&&r.push("--tags"),typeof t=="string"&&(n=t),[...r,e,n]},ve=async(e,t={})=>{const r=Ie(e,t);return await d("ls-remote",r)},Ee=(e,{delete:t=!1,force:r=!1,remote:n="origin",signed:s=!1}={})=>{const o=[n,e];return t?[n,"-d",e]:(r&&o.push("-f"),s!==!1&&o.push(`--signed=${s}`),o)},Se=async(e,t={})=>{const r=Ee(e,t);return await d("push",r)},_e=(e,{quiet:t=!1}={})=>{const r=[];return t&&r.push("-q"),[...r,"--",e]},Te=async(e,t={})=>{const r=_e(e,t);return await d("reset",r)},Pe=(e,{cached:t=!1,force:r=!1,ignoreUnmatch:n=!1,quiet:s=!1,recursive:o=!1}={})=>{const a=[];return r&&a.push("-f"),t&&a.push("--cached"),n&&a.push("--ignore-unmatch"),s&&a.push("-q"),o&&a.push("-r"),[...a,"--",e]},be=async(e,t={})=>{const r=Pe(e,t);return await d("rm",r)},Ne=(e,{commit:t,delete:r=!1,force:n=!1,list:s=!1,message:o="",sign:a=!1}={})=>{if(r)return["-d",e];if(s)return e===""?["-l"]:["-l",e];const u=[];return n&&u.push("-f"),a&&u.push("-s"),u.push(e),t!==void 0&&u.push(t),[...u,"-m",`${o}`]},ke=async(e,t={})=>{const r=Ne(e,t);return await d("tag",r)},Re=e=>({value:e,enumerable:!0,configurable:!1,writable:!1}),Oe=(e,t)=>{Object.keys(t).forEach(r=>{const n=Re(t[r]);Object.defineProperty(e,r,n)})};Oe(d,{add:ye,commit:me,config:N,getConfig:m,setConfig:h,lsRemote:ve,push:Se,reset:Te,rm:be,tag:ke});const Ue=e=>({value:e,enumerable:!0,configurable:!1,writable:!1}),Ae=(e,t)=>{Object.keys(t).forEach(r=>{const n=Ue(t[r]);Object.defineProperty(e,r,n)})},I=e=>`\x1B[${e}m`,Ce=I(31),Le=I(32),Ke=I(33),Me=I(34),He=I(37),We=I(90),xe=I(91),v=(e,t,r="\x1B[39m")=>e.split(`
`).map(n=>(n=t+n,n=n.endsWith("\r")?n.slice(0,-1)+r+"\r":n+r,n)).join(`
`),je=e=>{console.log(v(e,xe))},Fe=e=>{console.log(v(e,Ce))},k=e=>{console.log(v(e,Ke))},qe=e=>{console.log(v(e,Me))},_=e=>{console.log(v(e,Le))},T=e=>{console.log(v(e,We))},De=e=>{console.log(v(e,He))},i=e=>{console.log(e)},Ve=(...e)=>{console.log(...e)};Ae(Ve,{fatal:je,error:Fe,warn:k,info:qe,success:_,debug:T,trace:De,log:i});const Be="gpg-agent.conf",H=".gnupg",Ye={WIN32:"win32"},W=`default-cache-ttl 21600
max-cache-ttl 31536000
allow-preset-passphrase
`,x=(e,t=!1)=>e.split(/\n\r|\r\n|\r|\n/).map(r=>t?r.trim():r),R=async(e,t=[],r={})=>{const n=await C.execa(e,t,r),s=x(n.stderr,!0),o=x(n.stdout,!0);return{...n,stderrLines:s,stdoutLines:o}},ze=e=>{try{return $.statSync(e).isDirectory()}catch{return!1}},P=async e=>{const{stdout:t}=await R("gpg-connect-agent",[e,"/bye"]);return t},j=async(e,t)=>{const r=S.join(e,Be);$.writeFileSync(r,t),await P("RELOADAGENT")},E=async(e=[],t={})=>await R("gpg",e,t),Xe=async e=>{const t=["--batch","--yes",e],r=n=>[...t.slice(0,2),n,...t.slice(-1)];await E(r("--delete-secret-keys")),await E(r("--delete-keys"))},Je=async(e=[])=>await R("gpgconf",e),Qe=(e,t)=>e.slice(t.length+1).replace("%3a",":").trim(),O=async()=>{const e=["--list-dirs"],{stdoutLines:t}=await Je(e),r={libdir:"",libexecdir:"",datadir:"",homedir:""};return t.forEach(n=>{Object.keys(r).forEach(s=>{const o=s;n.startsWith(`${o}:`)&&(r[o]=Qe(n,o))})}),Object.keys(r).forEach(n=>{const s=r[n];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${n}`,{cause:s})}),r},Ze=async()=>{const{GNUPGHOME:e,HOME:t,USERPROFILE:r}=p.env;if(typeof e=="string"&&e!=="")return e;if(typeof t=="string"&&t!=="")return S.join(t,H);if(typeof r=="string"&&r!==""&&L.platform()===Ye.WIN32)return S.join(r,H);const{homedir:n}=await O();return n},F=async()=>{const e=await Ze();if(e.length===0)throw new Error("Unable to determine GnuPG home directory",{cause:e});return $.existsSync(e)||$.mkdirSync(e,{recursive:!0}),e},q=(e,t)=>{let r="",n=!1;for(const s of e){if(s.startsWith("fpr:")&&s.includes(`:${t}:`)){n=!0;continue}if(s.startsWith("grp:")&&n){r=s.replace(/(grp|:)/g,"").trim();break}}return r},D=async e=>{const t=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdoutLines:r}=await E(t);return q(r,e)},V=async e=>{const t=["--batch","--with-colons","--with-keygrip","--list-secret-keys",e],{stdoutLines:r}=await E(t),n=[];return r.forEach(s=>{s.startsWith("grp")&&n.push(s.replace(/(grp|:)/g,"").trim())}),n},U=(e,t)=>e.slice(t.length+1).trim(),B=async()=>{const e=["--version"],{stdoutLines:t}=await E(e),r={gnupg:"",libgcrypt:""};return t.forEach(n=>{n.startsWith("gpg (GnuPG) ")?r.gnupg=U(n,"gpg (GnuPG)"):n.startsWith("gpg (GnuPG/MacGPG2) ")?r.gnupg=U(n,"gpg (GnuPG/MacGPG2)"):n.startsWith("libgcrypt ")&&(r.libgcrypt=U(n,"libgcrypt"))}),Object.keys(r).forEach(n=>{const s=r[n];if(typeof s!="string"||s==="")throw new Error(`Invalid GPG ${n}`,{cause:s})}),r},et=e=>e.trimStart().startsWith("---"),Y=e=>et(e)?e:Buffer.from(e,"base64").toString(),tt=async e=>{const t=Y(e),r=await fe.readKey({armoredKey:t}),{user:n}=await r.getPrimaryUser(),s=r.getFingerprint().toUpperCase(),o=r.getKeyID().toHex().toUpperCase(),a=M(Ge),{name:u,address:c}=a(n.userID?.userID??"")[0],l=r.getCreationTime();return{digest:s,id:o,name:u,email:c,creationTime:l}},z=async e=>{const t=S.join(L.tmpdir(),`mnrendra-import-gpg-${K.nanoid()}`),r=$.mkdtempSync(t),n=`${r}/${K.nanoid()}.pgp`,s=Y(e);$.writeFileSync(n,s,{mode:384});const o=["--import","--batch","--yes",n],{stdout:a,stderr:u}=await E(o);return u!==""?u:($.unlinkSync(n),$.rmSync(r),a)},rt=async()=>{await P("KILLAGENT")},A=async(e,t)=>{const r=Buffer.from(t,"utf8").toString("hex").toUpperCase();return await P(`PRESET_PASSPHRASE ${e} -1 ${r}`),await P(`KEYINFO ${e}`)},X=async(e,t)=>{const r=["--batch","--no-tty","--command-fd","0","--edit-key",e],n=Buffer.from(`trust
${t}
y
quit
`);await E(r,{input:n})};var J={GPG_AGENT_CONF:W,configureAgent:j,deleteKey:Xe,getDirs:O,getHome:F,getKeygrip:D,getKeygrips:V,getVersion:B,importKey:z,killAgent:rt,parseKeygripFromGpgColonsOutput:q,presetPassphrase:A,setTrust:X};const Q="user.signingkey",Z="user.name",ee="user.email",te="commit.gpgsign",re="tag.gpgsign",ne="push.gpgsign",nt=async(e,t,r,{scope:n,signUser:s,signCommit:o,signTag:a,signPush:u})=>{i("---------------- Configuring Git ---------------------------------");const c={scope:"local",userSigningkey:"",commitGpgsign:!1,tagGpgsign:!1,pushGpgsign:!1,userName:"",userEmail:""};return c.scope=n,i(`scope           : ${c.scope}`),s&&(await h(Q,e,n),c.userSigningkey=await m(Q,n),i(`user.signingkey : ${c.userSigningkey}`),await h(Z,t,n),c.userName=await m(Z,n),i(`user.name       : ${c.userName}`),await h(ee,r,n),c.userEmail=await m(ee,n),i(`user.email      : ${c.userEmail}`)),o&&(await h(te,o,n),c.commitGpgsign=await m(te,n),i(`commit.gpgsign  : ${c.commitGpgsign}`)),a&&(await h(re,a,n),c.tagGpgsign=await m(re,n),i(`tag.gpgsign     : ${c.tagGpgsign}`)),u!==!1&&(await h(ne,u,n),c.pushGpgsign=await m(ne,n),i(`push.gpgsign    : ${c.pushGpgsign}`)),c},st=async(e,t,r)=>{const n={gpgHome:"",keygrips:[]};if(r===void 0)return n;const s=await F();if(await j(s,W),n.gpgHome=s,i("---------------- Configuring GnuPG agent -------------------------"),i(`GnuPG home      : ${s}`),t!==void 0){i("---------------- Getting keygrip for fingerprint -----------------");const o=await D(t);i(`Presetting passphrase for key ${t} with keygrip ${o}`);const a=await A(o,r);T(a),n.keygrips=[o]}else{i("---------------- Getting keygrips --------------------------------");const o=await V(e);for(const a of o){i(`Presetting passphrase for ${a}`);const u=await A(a,r);T(u)}n.keygrips=o}return n},it=async()=>{const e=await B(),t=await O(),r={...e,...t};Object.keys(r).forEach(s=>{const o=r[s];if(typeof o!="string"&&o==="")throw new Error(`Invalid GPG ${s} value`,{cause:o})});const n=`${r.gnupg} (libgcrypt ${r.libgcrypt})`;return i("---------------- GnuPG info --------------------------------------"),i(`Version         : ${n}`),i(`Libdir          : ${r.libdir}`),i(`Libexecdir      : ${r.libexecdir}`),i(`Datadir         : ${r.datadir}`),i(`Homedir         : ${r.homedir}`),{...r,version:n}},ot=async e=>{const{digest:t,id:r,name:n,email:s,creationTime:o}=await tt(e);return i("---------------- GPG private key info ----------------------------"),i(`Fingerprint     : ${t}`),i(`KeyID           : ${r}`),i(`Name            : ${n}`),i(`Email           : ${s}`),i(`CreationTime    : ${o.toUTCString()}`),{digest:t,id:r,name:n,email:s,creationTime:o}},at=async(e,t)=>{i("---------------- Importing GPG private key -----------------------");const r=await z(e);return i(r),r},ct=(e,t)=>{i("---------------- Fingerprint to use ------------------------------"),i(t??e)},b={cwd:p.cwd(),verbose:!1},se=e=>{Object.keys(e).forEach(t=>{b[t]=e[t]})},ie=()=>{const e=p.cwd(),t=b.cwd;e!==t&&(i("---------------- Restore working directory -----------------------"),p.chdir(t),i(`Restore working directory to ${t}.`))},ut=async(e,t)=>{if(t===void 0)return"";const r=Number(t);if(Number.isNaN(r)||r<1||r>5)throw new Error("Invalid GPG Trust Level value",{cause:t});return i("---------------- Setting key's trust level ----------------------"),await X(e,t),i(`Trust level set to ${t} for ${e}`),`Trust level set to ${t} for ${e}`},gt=async e=>{const t=p.cwd();se({...b,cwd:t});const r=S.resolve(e);t!==r&&(i("---------------- Change working directory ------------------------"),p.chdir(r),i(`Using ${r} as working directory...`))},lt=(e=".")=>{if(typeof e!="string"||e==="")throw new Error("Invalid workdir value",{cause:e});if(!ze(e))throw new Error(`workdir ${e} is doesn't exist`,{cause:e});return e},pt=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid passphrase value",{cause:e});return e}},ft=e=>{if(e!==void 0){if(typeof e!="string"||e==="")throw new Error("Invalid fingerprint value",{cause:e});return e}},Gt=e=>{if(e===void 0)return;const t=Number(e);if(Number.isNaN(t)||t<1||t>5)throw new Error("Invalid trustLevel value",{cause:e});return e},dt=(e="local")=>{if(typeof e!="string"||!["global","local"].includes(e))throw new Error("Invalid gitScope value",{cause:e});return e},wt=(e=!0)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignUser value",{cause:e});return e},yt=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignCommit value",{cause:e});return e},$t=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid gitSignTag value",{cause:e});return e},mt=(e=!1)=>{if(typeof e!="boolean"&&(typeof e!="string"||e!=="if-asked"))throw new Error("Invalid gitSignPush value",{cause:e});return e},ht=(e=!1)=>{if(typeof e!="boolean")throw new Error("Invalid verbose value",{cause:e});return e},It=e=>{if(typeof e!="object"||e===null||Array.isArray(e))throw new Error("Invalid options value",{cause:e});const t=lt(e.workdir),r=pt(e.passphrase),n=ft(e.fingerprint),s=Gt(e.trustLevel),o=dt(e.gitScope),a=wt(e.gitSignUser),u=yt(e.gitSignCommit),c=$t(e.gitSignTag),l=mt(e.gitSignPush),w=ht(e.verbose);return se({...b,verbose:w}),i("---------------- importGPG's options to use ---------------------"),i(`workdir         : ${t}`),i(`passphrase      : ${r}`),i(`fingerprint     : ${n}`),i(`trustLevel      : ${s}`),i(`gitScope        : ${o}`),i(`gitSignUser     : ${a}`),i(`gitSignCommit   : ${u}`),i(`gitSignTag      : ${c}`),i(`gitSignPush     : ${l}`),i(`verbose         : ${w}`),{workdir:t,passphrase:r,fingerprint:n,trustLevel:s,gitScope:o,gitSignUser:a,gitSignCommit:u,gitSignTag:c,gitSignPush:l,verbose:w}},vt=async(e,t={})=>{try{if(typeof e!="string"||e==="")throw new Error("Invalid GnuPG private key",{cause:e});const r=It(t),{workdir:n,fingerprint:s,passphrase:o,trustLevel:a}=r;await gt(n);const u=await it(),c=await ot(e),{digest:l,id:w,name:oe,email:ae}=c;ct(l,s);const ce=await at(e),ue=await st(l,s,o);await ut(w,a),_("---------------- Successfully set up GPG key ---------------------");const ge={scope:r.gitScope,signUser:r.gitSignUser,signCommit:r.gitSignCommit,signTag:r.gitSignTag,signPush:r.gitSignPush},y=await nt(w,oe,ae,ge);_("---------------- Successfully configured Git ---------------------");const le={...u,...c,...ue,...y,keyid:w,fingerprint:s??l,log:ce,trustLevel:a,gitConfigScope:y.scope,gitUserSigningkey:y.userSigningkey,gitUserName:y.userName,gitUserEmail:y.userEmail,gitCommitGpgsign:y.commitGpgsign,gitTagGpgsign:y.tagGpgsign,gitPushGpgsign:y.pushGpgsign,workdir:p.cwd()};return ie(),le}catch(r){throw ie(),r instanceof Error?r:new Error("Unknown error",{cause:r})}},Et=async(e="")=>{if(e.length<=0){T("Primary key fingerprint is not defined. Skipping cleanup.");return}try{i("---------------- Cleaning up GPG key -----------------------------"),i(`Removing key ${e}`),await J.deleteKey(e),i("Killing GnuPG agent"),await J.killAgent(),_("---------------- Successfully cleaned up GPG key -----------------")}catch(t){const r=t instanceof Error?t.message:"Unknown error";k(r),k(`${t}`)}},St=["alpha","beta","rc"],_t=St.map(e=>({name:e,prerelease:!0})),Tt=["+([0-9])?(.{+([0-9]),x}).x","main","next",..._t],Pt="/action",bt=["docs","style","refactor","perf","test","build","ci","chore","revert"],Nt=bt.map(e=>({type:e,release:"patch"})),kt=[["@semantic-release/commit-analyzer",{releaseRules:Nt}],"@semantic-release/release-notes-generator",["@semantic-release/npm",{npmPublish:!1}],[`${Pt}/@mnrendra/semantic-release-plugin-github-action`,{actionFile:"action.yml",ignoreFile:".ghaignore",releaseMessage:`release: v{nextRelease.version}

{nextRelease.notes}`,latestMessage:`latest: v{nextRelease.version}

{nextRelease.notes}`,sign:!0}],"@semantic-release/github"],Rt={branches:Tt,plugins:kt,dryRun:!1,ci:!0},Ot=()=>{if(typeof p.env!="object"||p.env===null||Array.isArray(p.env))return{};const e={};return Object.keys(p.env).filter(t=>t.startsWith("ACTIONS_")||t.startsWith("CI")||t.startsWith("GITHUB_")||t.startsWith("INPUT_")||t.startsWith("RUNNER_")).sort().forEach(t=>{e[t]=p.env[t]}),e},G=Object.freeze({WORKDIR:".",GPG_PRIVATE_KEY:void 0,GPG_PASSPHRASE:void 0,GPG_FINGERPRINT:void 0,GPG_TRUST_LEVEL:void 0,GIT_SCOPE:"local",GIT_SIGN_USER:!0,GIT_SIGN_COMMIT:!1,GIT_SIGN_TAG:!1,GIT_SIGN_PUSH:!1,TOKEN:p.env.GITHUB_TOKEN}),g=Object.freeze({WORKDIR:"workdir",GPG_PRIVATE_KEY:"gpg-private-key",GPG_PASSPHRASE:"gpg-passphrase",GPG_FINGERPRINT:"gpg-fingerprint",GPG_TRUST_LEVEL:"gpg-trust-level",GIT_SCOPE:"git-scope",GIT_SIGN_USER:"git-sign-user",GIT_SIGN_COMMIT:"git-sign-commit",GIT_SIGN_TAG:"git-sign-tag",GIT_SIGN_PUSH:"git-sign-push",TOKEN:"token"}),Ut=()=>{const e=f.getInput(g.GPG_FINGERPRINT);if(e===void 0||e==="")return G.GPG_FINGERPRINT;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_FINGERPRINT} input`,{cause:e});return e},At=()=>{const e=f.getInput(g.GIT_SCOPE);if(e===void 0||e==="")return G.GIT_SCOPE;if(typeof e!="string"||!["global","local"].includes(e))throw new Error(`Invalid ${g.GIT_SCOPE} input`,{cause:e});return e},Ct=()=>{const e=f.getInput(g.GIT_SIGN_COMMIT);if(e===void 0||e==="")return G.GIT_SIGN_COMMIT;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_COMMIT} input`,{cause:e})}},Lt=()=>{const e=f.getInput(g.GIT_SIGN_PUSH);if(e===void 0||e==="")return G.GIT_SIGN_PUSH;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;case"if-asked":return"if-asked";default:throw new Error(`Invalid ${g.GIT_SIGN_PUSH} input`,{cause:e})}},Kt=()=>{const e=f.getInput(g.GIT_SIGN_TAG);if(e===void 0||e==="")return G.GIT_SIGN_TAG;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_TAG} input`,{cause:e})}},Mt=()=>{const e=f.getInput(g.GIT_SIGN_USER);if(e===void 0||e==="")return G.GIT_SIGN_USER;if(typeof e=="boolean")return e;switch(e){case"false":return!1;case"true":return!0;default:throw new Error(`Invalid ${g.GIT_SIGN_USER} input`,{cause:e})}},Ht=()=>{const e=f.getInput(g.GPG_PASSPHRASE);if(e===void 0||e==="")return G.GPG_PASSPHRASE;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_PASSPHRASE} input`,{cause:e});return e},Wt=()=>{const e=f.getInput(g.GPG_PRIVATE_KEY);if(e===void 0||e==="")return G.GPG_PRIVATE_KEY;if(typeof e!="string")throw new Error(`Invalid ${g.GPG_PRIVATE_KEY} input`,{cause:e});return e},xt=()=>{const e=f.getInput(g.TOKEN);if(e===void 0||e==="")return G.TOKEN;if(typeof e!="string")throw new Error(`Invalid ${g.TOKEN} input`,{cause:e});return e},jt=()=>{const e=f.getInput(g.GPG_TRUST_LEVEL);if(e===void 0||e==="")return G.GPG_TRUST_LEVEL;const t=Number(e);if(Number.isNaN(t)||t<1||t>5)throw new Error(`Invalid ${g.GPG_TRUST_LEVEL} input`,{cause:e});return t},Ft=()=>{const e=f.getInput(g.WORKDIR);if(e===void 0||e==="")return G.WORKDIR;if(typeof e!="string")throw new Error(`Invalid ${g.WORKDIR} input`,{cause:e});return e},qt=()=>{const e=Ut(),t=At(),r=Ct(),n=Lt(),s=Kt(),o=Mt(),a=Ht(),u=Wt(),c=xt(),l=jt(),w=Ft();return{fingerprint:e,gitScope:t,gitSignCommit:r,gitSignPush:n,gitSignTag:s,gitSignUser:o,passphrase:a,privateKey:u,token:c,trustLevel:l,workdir:w}},Dt=async()=>{await d.setConfig("safe.directory",de,"global");const e=Ot();console.log("Environments:",e);const t=qt();let r="",n="GitOps Release",s="gitops-release@users.noreply.github.com",o=p.cwd();const{privateKey:a,token:u}=t;if(a!==void 0){const l=await vt(a,{...t,verbose:!0});r=l.digest,n=l.name,s=l.email,o=l.workdir}const c=await M(pe)(Rt,{env:{...p.env,GIT_AUTHOR_NAME:n,GIT_AUTHOR_EMAIL:s,GIT_COMMITTER_NAME:n,GIT_COMMITTER_EMAIL:s,GITHUB_TOKEN:u}});return c!==!1?console.log("release:",c.nextRelease.version):console.warn("failed to release!"),await Et(r),o};Dt().then(e=>{console.log("hasil:",e)}).catch(e=>{throw e instanceof Error?e:new Error("Unknown error")});
